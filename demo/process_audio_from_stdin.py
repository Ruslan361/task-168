import sys
import os # Импортируем os для получения имени скрипта
import time
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', encoding='utf-8')

logging.info(f"Скрипт {os.path.basename(__file__)} запущен и ожидает бинарные данные на стандартном вводе.")

# Читаем бинарные данные блоками
# Размер блока можно подобрать, например, 4096 байт, или любой другой разумный размер
# Это должно соответствовать размеру чанков, которые отправляет operator.js или server.js
BLOCK_SIZE = 4096

try:
    # sys.stdin.buffer позволяет читать бинарные данные напрямую из stdin
    # В отличие от sys.stdin, который ожидает текст
    while True:
        # Читаем блок бинарных данных
        # read() блокируется, пока данные не будут доступны или поток не закроется
        data = sys.stdin.buffer.read(BLOCK_SIZE)

        if not data:
            # Если read() возвращает пустые байты, это означает конец стандартного ввода
            logging.info("Получен сигнал конца стандартного ввода (EOF). Завершение работы.")
            break

        # Если данные получены, выводим информацию о них
        logging.info(f"Получено {len(data)} байт бинарных данных.")

        # Опционально: можно вывести первые несколько байт для отладки
        # logging.debug(f"Первые 10 байт: {data[:10].hex()}")

        # В реальном скрипте здесь вы бы обрабатывали эти данные
        # Например, добавляли бы их в буфер для VAD/Whisper транскрипции
        # process_audio_data(data) # Вызов вашей функции обработки

except Exception as e:
    logging.error(f"Произошла ошибка при чтении из стандартного ввода: {e}")
except KeyboardInterrupt:
    logging.info("Получен сигнал прерывания (Ctrl+C). Завершение работы.")
finally:
    # Гарантированное выполнение при выходе из цикла или ошибке
    logging.info(f"Скрипт {os.path.basename(__file__)} завершает работу.")
    sys.stdout.flush() # Убедимся, что все логи выведены